Packages

= They are not magic =

One thing I find continually baffling is that many people I encounter
on the Internet ascribe near-magical powers to packages.  Like that
somehow by writing a .spec or debian/ directory, the a lot of problems
are solved for you, and you don't have to think much.

The reality is that packages are much more of a tool than a direct
easy solution to anything.  The right way to look at them is similar
to a C compiler - they have a source language you can input things
into, and they generate binaries.

But you can easily have horrible bugs in your packages, the same way C
programs can have bugs.  This is most obvious when you note that the
major well-known package frameworks have arbitrary shell scripts run
as root attached.

The purpose of this document isn't to say all packages are bad - as
you will see later I think they're great in a MacPorts type role.  But
even then, packages are not a substitute for careful thought.

= The upgrade problem =

One problem I feel like I'm alone in seeing is the massive set of race
conditions created during an "apt-get/urpmi/yum/whatever upgrade".
The question is - what operations do we allow the user to perform
during an upgrade process?  At present, the major "distros" are only
poorly vertically integrated - in the GNOME 2 days, maybe you have a
PackageKit icon sitting in the status tray at best.  If you run
"$tool upgrade" from a terminal, you're left logged in, your
applications open.

But note how these implement upgrades - they simply live replace files
on your root filesystem with new versions and delete old no longer
shipped files.  There set of race conditions here is almost endless.

The major sources of race conditions are:

1) The user launching new applications
2) Running applications which might open a file (either dlopen() a plugin or data)
3) System background services (cron/at)
4) DBus system activation of services

Let's just think of a simple example:

== A security update for libX11 ==

This is a very simple package:

$ rpm -ql libX11
/usr/lib64/libX11-xcb.so.1
/usr/lib64/libX11-xcb.so.1.0.0
/usr/lib64/libX11.so.6
/usr/lib64/libX11.so.6.3.0
$

Note that libX11-xcb.so depends on libX11.so.  It's entirely possible
that the new libX11-xcb.so depends on a new symbol added in libX11.so.
During the upgrade process, there will be a state where you have
either the OLD libX11.so and the NEW libX11-xcb.so, or the NEW
libX11.so and the OLD libX11-xcb.so.

If the user launches an application, it's entirely possible that the
dynamic linker will see the files in this state, and thus the launched
application will have a totally untested and possibly buggy
combination of libraries - if there is indeed a new symbol dependency
introduced, the user experience will be an application crash.

Launching it again will probably work.

== Applications with data files ==

This is a huge problem - if you "rpm -ql firefox" you'll see it has a
ton of language packs, XML data for search providers, icons,
JavaScript code, etc.  But it's NOT just firefox - look at the
gnome-terminal package, it has 6 different glade XML files, as well as
a schemas file.  Rhythmbox has glade files and plugins.  Evolution is
even more complex.

What if the application is already running?  Then it's possible if the
user clicks on a button or menu item that the application in turn
opens one of the data files.  Then it's possible the OLD application
instance sees a NEW version of the data file.  Let's say the file in
question is a glade UI file.  If the NEW application changed the
layout, it's entirely possible that this just causes a segfault as the
OLD application can't find a widget it expected.

== Apps can be launched while partially installed ==

This one is obvious.  There's no vertical integration between the
"package system" and the desktop UI - typical state of the art is to
use inotify to pick up new .desktop files.  But unless the .desktop
file is placed down last, there is nothing preventing the user from
clicking on that icon while in the background the executable or data
files are being created!  

"This app I just installed crashed!"

== Background services ==

This is similar to the user launching apps, except it could happen
even if the user walks away from the computer immediately after
starting an upgrade.

= What can we do to fix this? =

Hopefully by this point you agree with me that there's a serious
problem, and what you're wondering is how to solve it.

For the existing package systems, probably the simplest thing would be
to have them just download updates, and only apply them at shutdown
(or startup).

This would mean you'd need to reboot for a firefox upgrade though.  Oh
and even if you did this, there would still be the application
installation race condition above.

Almost any other solution requires *vertical integration* - anathema
to many people in package/distribution communities.  This is where the
combinatorial forking in FOSS really, really hurts.  In theory, we
could just pick one package system, fix it up, and say GNOME only
works with it.

The reason as a GNOME hacker I don't want to take that approach is
because it implies *compatibility* with whatever distro base we pick.
And that's a long term hell to be in (see Ubuntu).  If we're not
compatible, there's not a lot of point to trying to maintain a
targeted for as to just building something very targeted that works
for us in GNOME.

= Package systems allow totally insane things =

As a GNOME maintainer, I would quite simply never want to support
operations such as "apt-get remove pulseaudio".

= Package systems don't really help 3rd parties =

How much "we" as a FOSS community, or just in GNOME support 3rd party
proprietary software is a controversial topic, to say the least.  But
note that package systems and 3rd party repositories don't help much -
what they need is *stable* API to plug in to.  And GNOME is the right
place to define stable APIs (along with LSB).

= Whole system testing and upgrade state =

So we see how present package systems simply have no idea how to
reliably upgrade while the system is running - but even worse, most
package systems by their very nature create a situation in which
everybody has a *different* installation. 

This "system drift" greatly makes automated testing far harder, and
devalues it.

Even worse, "apt-get upgrade" process calculates the upgrade based on
what you have installed - so if you have a system installed for a long
time, it can look different from a new installation with the same apps.

= Why isn't this fixed yet?  =

I've wondered about this for a long time - how can it be that all the
core developers in Debian/Fedora are so blind as to how unreliable the
system is?

I finally realized - many of these people came to FOSS as tinkerers.
The proposition of a system where you can dynamically
add/remove/exchange bits of the operating system were very appealing.

Let me suggest that there is a fundamental tradeoff between the
flexibility and reliability.  Many (possibly most) of the people in
these communities would keep the dial close to flexibility, despite
the cost to reliability.

Personally, I'm over 30 now.  I once watched one of my friends using
Ubuntu install security updates and be confused by their patch to
firefox to pop up a "I'm broken now" dialog.  Screw that.  I'm turning
the dial towards reliability.








